import { generateText } from "ai"
import { openai } from "@ai-sdk/openai"
import { extractFullArticleContent } from "./content-extractor"

export interface SummaryResult {
  success: boolean
  title?: string
  summary?: string
  keyPoints?: string[]
  severity?: "routine" | "attention" | "urgent"
  damageCategory?: "private" | "commercial" | "industrial" | "infrastructure"
  businessInterruption?: boolean
  estimatedComplexity?: "low" | "medium" | "high" | "critical"
  location?: string // KI-extrahierter Ort
  locationConfidence?: "low" | "medium" | "high" // Genauigkeit
  keywords?: string[] // üÜï KI-extrahierte Keywords
  keywordCategories?: {
    // üÜï Kategorisierte Keywords
    eventType?: string
    severity?: string
    sector?: string
    damageType?: string
    urgency?: string
  }
  keywordConfidence?: { [key: string]: number } // üÜï Confidence-Scores
  error?: string
}

function cleanJsonResponse(text: string): string {
  // Remove markdown code blocks
  text = text.replace(/```json\s*/g, "").replace(/```\s*/g, "")

  // Remove any leading/trailing whitespace
  text = text.trim()

  // Find JSON object boundaries
  const jsonStart = text.indexOf("{")
  const jsonEnd = text.lastIndexOf("}") + 1

  if (jsonStart !== -1 && jsonEnd > jsonStart) {
    text = text.substring(jsonStart, jsonEnd)
  }

  return text
}

function parseAIResponse(text: string): any {
  try {
    // First, try direct parsing
    return JSON.parse(text)
  } catch (error) {
    try {
      // Clean the text more aggressively
      let cleanedText = cleanJsonResponse(text)

      // Remove any remaining markdown or formatting
      cleanedText = cleanedText
        .replace(/^[^{]*/, "") // Remove everything before first {
        .replace(/[^}]*$/, "") // Remove everything after last }
        .replace(/\n/g, " ") // Replace newlines with spaces
        .replace(/\s+/g, " ") // Normalize whitespace

      return JSON.parse(cleanedText)
    } catch (secondError) {
      // Try to extract JSON with regex as last resort
      const jsonMatch = text.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/)
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0])
      }

      console.error("Failed to parse AI response:", text.substring(0, 500))
      throw new Error(`Could not parse JSON response: ${text.substring(0, 200)}...`)
    }
  }
}

export async function generateNewsSummary(
  title: string | null,
  content: string | null,
  location: string | null,
  originalUrl?: string | null,
): Promise<SummaryResult> {
  try {
    if (!process.env.OPENAI_API_KEY) {
      return {
        success: false,
        error: "OpenAI API Key ist nicht konfiguriert. Bitte OPENAI_API_KEY Umgebungsvariable setzen.",
      }
    }

    if (!title && !content) {
      return {
        success: false,
        error: "Kein Inhalt zum Zusammenfassen vorhanden",
      }
    }

    // Erweiterte Content-Extraktion wenn URL verf√ºgbar
    let enhancedContent = content
    let extractionInfo = ""

    if (originalUrl && originalUrl.startsWith("http")) {
      console.log(`üîç Attempting full content extraction for: ${originalUrl}`)

      try {
        const extractedResult = await extractFullArticleContent(originalUrl, content || undefined)

        if (extractedResult.success && extractedResult.content) {
          enhancedContent = extractedResult.content
          extractionInfo = ` (Content via ${extractedResult.extractionMethod})`
          console.log(`‚úÖ Enhanced content: ${enhancedContent.length} chars vs original ${content?.length || 0} chars`)
        } else {
          console.log(`‚ö†Ô∏è Content extraction failed: ${extractedResult.error}`)
        }
      } catch (error) {
        console.warn(`‚ùå Content extraction error: ${error}`)
        // Fallback auf urspr√ºnglichen Content
      }
    }

    const textToSummarize = [title, enhancedContent].filter(Boolean).join("\n\n")

    console.log(`ü§ñ Generating AI summary for: ${title?.substring(0, 50)}...${extractionInfo}`)

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      system: `Du bist ein Experte f√ºr die Bewertung von Schadensmeldungen aus Sicht eines Sachverst√§ndigenb√ºros f√ºr Geb√§udesch√§den, TKBE und Betriebsunterbrechung.

üß† INTELLIGENTE SCHADENSANALYSE - Denke logisch, nicht nach Keywords!

ANALYSIERE SCHRITT F√úR SCHRITT:

1Ô∏è‚É£ OBJEKT & NUTZUNG verstehen:
- WAS ist betroffen? (Geb√§ude, Anlage, Einrichtung)
- WER nutzt es? (Privatpersonen, Unternehmen, Organisationen)
- WOF√úR wird es genutzt? (Wohnen, Arbeiten, Produzieren, Verkaufen)

2Ô∏è‚É£ üìç EREIGNISORT INTELLIGENT EXTRAHIEREN:
- WO ist das Ereignis passiert? (Nicht nur erw√§hnte Orte!)
- Unterscheide zwischen EREIGNISORT und nur erw√§hnten Orten
- Beispiele:
  * "Feuerwehr aus K√∂ln hilft in D√ºsseldorf" ‚Üí D√ºsseldorf (Ereignisort)
  * "Brand in Hamburg-Altona" ‚Üí Hamburg-Altona (pr√§zise)
  * "Unfall auf A1 bei Bremen" ‚Üí Bremen (mit Kontext)
  * "Polizei M√ºnchen ermittelt" ‚Üí M√ºnchen (Ereignisort)

üéØ ORTSEXTRAKTION-REGELN:
- PR√ÑZISION: Stadtteil > Stadt > Region > Land
- KONTEXT: Wo passierte das Ereignis wirklich?
- INTERNATIONAL: Auch ausl√§ndische Orte erkennen
- GENAUIGKEIT bewerten:
  * HIGH: Eindeutig identifiziert (Stra√üe, Stadtteil)
  * MEDIUM: Stadt/Ort klar erkennbar
  * LOW: Nur Region/Land oder unklar

3Ô∏è‚É£ üè∑Ô∏è INTELLIGENTE KEYWORD-EXTRAKTION:

SACHVERST√ÑNDIGEN-RELEVANTE KEYWORDS:
- EREIGNISTYP: "Wasserschaden", "Brandschaden", "Sturmschaden", "Einbruchschaden"
- OBJEKTTYP: "Wohngeb√§ude", "B√ºrogeb√§ude", "Produktionshalle", "Einzelhandel"
- SCHADENSART: "Leitungswasserschaden", "Dachstuhlbrand", "Hagelschaden", "Vandalismus"
- KOMPLEXIT√ÑT: "Gro√üschaden", "Bagatellschaden", "Haftpflichtfall", "Regulierungsfall"
- BRANCHE: "Gastronomie", "Produktion", "Handel", "Dienstleistung", "Gesundheitswesen"
- BESONDERHEITEN: "Betriebsunterbrechung", "Mietausfall", "Mehrkosten", "Sachverst√§ndigenbedarf"

KEYWORD-KATEGORIEN:
- eventType: Hauptereignis (Brand, Wasser, Sturm, Einbruch, Unfall)
- severity: Schweregrad (Bagatelle, Mittel, Gro√ü, Katastrophe)
- sector: Betroffener Sektor (Wohnen, B√ºro, Industrie, Handel, Gastronomie)
- damageType: Spezifischer Schaden (Feuer, Rauch, L√∂schwasser, Hagel, Einbruch)
- urgency: Dringlichkeit (Routine, Beobachten, Sofort)

KEYWORD-QUALIT√ÑT:
- Nur RELEVANTE Keywords f√ºr Sachverst√§ndige
- SPEZIFISCH statt generisch ("Dachstuhlbrand" statt "Brand")
- FACHTERMINOLOGIE verwenden
- 3-8 Keywords pro Artikel
- Confidence-Score 0.0-1.0 f√ºr jedes Keyword

4Ô∏è‚É£ ERWEITERTE KATEGORISIERUNG (4 Kategorien):

üè† PRIVATE SCH√ÑDEN = Orte zum WOHNEN und LEBEN
- Jeder Ort, wo Menschen ihr ZUHAUSE haben
- Privatpersonen als Hauptbetroffene
- Wohnzweck steht im Vordergrund
- Beispiele: H√§user, Wohnungen, Eigenheime, WGs, Seniorenheime

üè¢ GEWERBLICHE SCH√ÑDEN = Orte zum ARBEITEN und GESCH√ÑFTE MACHEN
- B√ºros, Gesch√§fte, Praxen, Restaurants, kleinere Betriebe
- Dienstleistungsunternehmen, Handel, Gastronomie
- Beispiele: Arztpraxen, Anwaltskanzleien, Restaurants, Einzelhandel

üè≠ INDUSTRIELLE SCH√ÑDEN = PRODUKTION und FERTIGUNG
- Fabriken, Produktionsst√§tten, S√§gewerke, Werkst√§tten
- Schwere Maschinen, Produktionsanlagen
- Beispiele: S√§gewerke, Fabriken, Produktionshallen, Werkst√§tten

üèóÔ∏è INFRASTRUKTUR-SCH√ÑDEN = √ñFFENTLICHE EINRICHTUNGEN
- Schulen, Krankenh√§user, Beh√∂rden, Verkehrswege
- √ñffentliche Versorgung, Bildungseinrichtungen
- Beispiele: Schulen, Kitas, Krankenh√§user, Br√ºcken, Bahnh√∂fe

5Ô∏è‚É£ üö¶ AMPEL-BEWERTUNG (3 Stufen):

üü¢ ROUTINE = Zur Information, nur dokumentieren
- Kleine Sch√§den, Bagatellsch√§den
- Kein direkter Sachverst√§ndigenbedarf erkennbar
- Standard-Versicherungsabwicklung ausreichend
- Beispiele: Kleine Wassersch√§den, Fensterscheiben, Kleinreparaturen

üü° BEACHTEN = Aufmerksamkeit erforderlich, Entwicklung verfolgen
- Mittlere Sch√§den mit m√∂glichem SV-Bedarf
- Situation k√∂nnte sich entwickeln
- Bei Bedarf kontaktieren oder beobachten
- Beispiele: Gr√∂√üere Wassersch√§den, mittlere Brandsch√§den, unklare Haftung

üî¥ HANDELN = Dringend, sofort aktiv werden
- Gro√üsch√§den mit klarem SV-Bedarf
- Komplexe Schadenssituationen
- Umgehend Mandatsanfrage stellen
- Beispiele: Millionensch√§den, Gro√übr√§nde, komplexe Haftungsf√§lle, Betriebsunterbrechungen

6Ô∏è‚É£ ENTSCHEIDUNGSHILFEN:
- Bei WOHNGEB√ÑUDEN mit Gewerbe ‚Üí Hauptnutzung entscheidet
- Bei GEMISCHTER NUTZUNG ‚Üí Schwerpunkt der Betroffenheit
- Bei UNSICHERHEIT ‚Üí Frage: "Wer verliert hier haupts√§chlich was?"

7Ô∏è‚É£ TITEL-GENERIERUNG:
Erstelle pr√§gnante, sachverst√§ndigen-orientierte Titel:
- Schadensart + Objekttyp + Ort
- 50-80 Zeichen, professionell und pr√§zise
- Beispiele: "Brandschaden S√§gewerk Allendorf - Millionenschaden"

8Ô∏è‚É£ BETRIEBSUNTERBRECHUNG erkennen:
- Gibt es Hinweise auf Arbeitsausfall, Produktionsstopp?
- Sind Gesch√§ftst√§tigkeiten beeintr√§chtigt?
- Bei Gewerbe/Industrie: Fast immer TRUE, bei Privat: meist FALSE

WICHTIG: 
- Nutze dein ALLGEMEINWISSEN √ºber Geb√§udetypen und Nutzungen
- Denke LOGISCH, nicht nur nach Stichworten
- Ein S√ÑGEWERK ist OFFENSICHTLICH Industrie, auch ohne das Wort "Fabrik"
- Eine ZAHNARZTPRAXIS ist Gewerbe, auch wenn sie klein ist
- Ein RESTAURANT ist Gewerbe, egal ob "famili√§r" oder "klein"
- Eine SCHULE ist Infrastruktur, auch wenn privat betrieben

Antworte ausschlie√ülich mit einem g√ºltigen JSON-Objekt:

{
  "title": "Pr√§gnanter SV-orientierter Titel (50-80 Zeichen)",
  "summary": "Pr√§gnante Zusammenfassung in 2-3 S√§tzen",
  "keyPoints": ["3-5 wichtige Punkte f√ºr SV-Bewertung"],
  "severity": "routine|attention|urgent",
  "damageCategory": "private|commercial|industrial|infrastructure",
  "businessInterruption": true/false,
  "estimatedComplexity": "low|medium|high|critical",
  "location": "Pr√§ziser Ereignisort (Stadt, Stadtteil, Stra√üe)",
  "locationConfidence": "low|medium|high",
  "keywords": ["3-8 sachverst√§ndigen-relevante Keywords"],
  "keywordCategories": {
    "eventType": "Brand|Wasser|Sturm|Einbruch|Unfall|Sonstiges",
    "severity": "Bagatelle|Mittel|Gro√ü|Katastrophe",
    "sector": "Wohnen|B√ºro|Industrie|Handel|Gastronomie|Gesundheit|Bildung|Infrastruktur|Sonstiges",
    "damageType": "Spezifischer Schadenstyp",
    "urgency": "Routine|Beobachten|Sofort"
  },
  "keywordConfidence": {
    "keyword1": 0.95,
    "keyword2": 0.87
  }
}`,
      prompt: `Bewerte diese Schadensmeldung aus Sachverst√§ndigen-Sicht und erstelle einen professionellen Titel mit intelligenten Keywords:

Originaltitel: ${title || "Kein Titel"}
Urspr√ºnglicher Ort (RSS): ${location || "Unbekannt"}
Inhalt: ${textToSummarize}

ANALYSIERE SYSTEMATISCH:

1. TITEL erstellen:
   - Schadensart identifizieren (Brand, Wasser, Sturm, etc.)
   - Objekttyp bestimmen und logisch kategorisieren
   - Ort einbauen, pr√§gnant formulieren

2. üìç EREIGNISORT INTELLIGENT BESTIMMEN:
   - Analysiere den GESAMTEN Text nach dem tats√§chlichen Ereignisort
   - Ignoriere nur erw√§hnte Orte (z.B. "Feuerwehr aus X hilft in Y" ‚Üí Y ist Ereignisort)
   - Sei so PR√ÑZISE wie m√∂glich: Stadtteil > Stadt > Region
   - Bewerte deine GENAUIGKEIT ehrlich
   - Falls unklar: Nutze den urspr√ºnglichen RSS-Ort als Fallback

3. üè∑Ô∏è INTELLIGENTE KEYWORDS EXTRAHIEREN:
   - Fokus auf SACHVERST√ÑNDIGEN-RELEVANZ
   - SPEZIFISCHE Begriffe statt generische
   - Ber√ºcksichtige FACHTERMINOLOGIE
   - 3-8 Keywords mit hoher Relevanz
   - Bewerte Confidence f√ºr jedes Keyword (0.0-1.0)
   - Kategorisiere Keywords sinnvoll

4. ERWEITERTE SCHADENSKATEGORIE bestimmen (4 Kategorien):
   - PRIVATE: Wohnzweck, Privatpersonen betroffen?
   - COMMERCIAL: Gesch√§fts-/B√ºrozweck, kleinere Unternehmen?
   - INDUSTRIAL: Produktion/Fertigung, Fabriken, S√§gewerke?
   - INFRASTRUCTURE: √ñffentliche Einrichtungen, Schulen, Krankenh√§user?

5. AMPEL-BEWERTUNG (üö¶):
   - ROUTINE: Kleine Sch√§den, nur Info
   - ATTENTION: Mittlere Sch√§den, beobachten
   - URGENT: Gro√üe/komplexe Sch√§den, sofort handeln

6. BETRIEBSUNTERBRECHUNG pr√ºfen:
   - Sind Gesch√§ftst√§tigkeiten beeintr√§chtigt?

7. KOMPLEXIT√ÑT einsch√§tzen:
   - Einfache vs. komplexe Regulierung

Antworte nur mit dem JSON-Objekt ohne zus√§tzliche Formatierung.`,
    })

    // Parse JSON response with error handling
    const parsed = parseAIResponse(text)

    // Validate required fields
    if (!parsed.title || !parsed.summary || !parsed.keyPoints || !parsed.severity) {
      throw new Error("AI response missing required fields")
    }

    // Validate severity value (3-Stufen-Ampel)
    const validSeverities = ["routine", "attention", "urgent"]
    if (!validSeverities.includes(parsed.severity)) {
      parsed.severity = "attention" // Default zu Gelb
    }

    // Validate damage category (erweitert auf 4 Kategorien)
    const validCategories = ["private", "commercial", "industrial", "infrastructure"]
    if (!validCategories.includes(parsed.damageCategory)) {
      parsed.damageCategory = "private"
    }

    // Validate complexity
    const validComplexities = ["low", "medium", "high", "critical"]
    if (!validComplexities.includes(parsed.estimatedComplexity)) {
      parsed.estimatedComplexity = "medium"
    }

    // Validate location confidence
    const validConfidences = ["low", "medium", "high"]
    if (parsed.locationConfidence && !validConfidences.includes(parsed.locationConfidence)) {
      parsed.locationConfidence = "medium"
    }

    // üÜï Validate and process keywords
    let processedKeywords: string[] = []
    let keywordConfidence: { [key: string]: number } = {}

    if (Array.isArray(parsed.keywords)) {
      processedKeywords = parsed.keywords
        .filter((kw: any) => typeof kw === "string" && kw.trim().length > 0)
        .slice(0, 8) // Maximal 8 Keywords
    }

    // Process keyword confidence scores
    if (parsed.keywordConfidence && typeof parsed.keywordConfidence === "object") {
      keywordConfidence = parsed.keywordConfidence
    } else {
      // Generate default confidence scores if not provided
      processedKeywords.forEach((keyword) => {
        keywordConfidence[keyword] = 0.8 // Default confidence
      })
    }

    return {
      success: true,
      title: parsed.title,
      summary: parsed.summary,
      keyPoints: Array.isArray(parsed.keyPoints) ? parsed.keyPoints : [],
      severity: parsed.severity,
      damageCategory: parsed.damageCategory,
      businessInterruption: Boolean(parsed.businessInterruption),
      estimatedComplexity: parsed.estimatedComplexity,
      location: parsed.location || null,
      locationConfidence: parsed.locationConfidence || "medium",
      keywords: processedKeywords, // üÜï KI-extrahierte Keywords
      keywordCategories: parsed.keywordCategories || {}, // üÜï Kategorisierte Keywords
      keywordConfidence, // üÜï Confidence-Scores
    }
  } catch (error: any) {
    console.error("AI Summary Error:", error)

    // Spezifische Fehlerbehandlung f√ºr h√§ufige Probleme
    if (error.message?.includes("API key")) {
      return {
        success: false,
        error: "OpenAI API Key ist ung√ºltig oder nicht gesetzt. Bitte √ºberpr√ºfen Sie die Konfiguration.",
      }
    }

    if (error.message?.includes("quota")) {
      return {
        success: false,
        error: "OpenAI API Quota √ºberschritten. Bitte versuchen Sie es sp√§ter erneut.",
      }
    }

    if (error.message?.includes("rate limit")) {
      return {
        success: false,
        error: "OpenAI API Rate Limit erreicht. Bitte warten Sie einen Moment.",
      }
    }

    if (error.message?.includes("JSON") || error.message?.includes("parse")) {
      return {
        success: false,
        error: "KI-Antwort konnte nicht verarbeitet werden. Bitte versuchen Sie es erneut.",
      }
    }

    return {
      success: false,
      error: error.message || "Fehler bei der KI-Zusammenfassung",
    }
  }
}
